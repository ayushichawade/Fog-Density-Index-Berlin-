# -*- coding: utf-8 -*-
"""urbantech_fog.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hZzabsJtYlTWYxBJu0jXPaoYW8LbPxPW

# Fog Detection Index (FDI) Analysis for Berlin
This project calculates the Fog Detection Index (FDI) for Berlin using meteorological data such as wind speed, temperature, dew point, and relative humidity. The goal is to analyze fog formation potential, normalize the data for consistent scaling, and prepare it for visualization or further geospatial analysis.

#Download & Load OSM Map for Berlin


*   Berlin map data is available from OpenStreetMap as a .pbf file from Geofabrik.
*   The file contains roads and other geographical features of the city.


*   Loading the .pbf file allows processing and visualization of the city’s infrastructure.
"""

!pip install pyrosm

"""

*  Roads include major highways, secondary streets, residential, and link roads
*   Each road has geometric coordinates representing its location and shape

*   Road types are classified by highway category
*   The data structure allows spatial analysis and integration with meteorological information







"""

from pyrosm import OSM
import pandas as pd

pbf_file = "berlin-260205.osm.pbf"
osm = OSM(pbf_file)

highway_values = [
    "motorway", "trunk", "primary", "secondary", "tertiary",
    "residential", "unclassified",
    "motorway_link", "trunk_link", "primary_link", "secondary_link", "tertiary_link"
]

roads = osm.get_data_by_custom_criteria(
    custom_filter={"highway": highway_values},
    filter_type="keep"
)

roads_df = pd.DataFrame(roads)
print(roads_df.head())

"""Other columns in the OSM road data may exist, but for fog analysis, the focus is on geometry and highway type, additional attributes can be evaluated later if needed."""

roads_df.columns

roads_df['access'].unique()

roads_df['highway'].unique()

roads_df['junction'].unique()

roads_df['est_width'].unique()

roads_df['name'].unique()

roads_df_filterd = roads[["geometry", "highway"]]
print(roads_df_filterd.head())

"""## Boundaries of Berlin are extracted from the OSM data, providing polygonal outlines of administrative areas for spatial analysis.

Unique boundary names and their administrative levels are displayed to understand the hierarchy of areas within Berlin.
"""

boundaries = osm.get_boundaries()
print(boundaries.head())

pd.set_option('display.max_rows', None)

print(boundaries[["name", "admin_level"]].drop_duplicates())

"""##The GeoDataFrame is filtered to focus on Mitte, allowing interactive exploration and analysis of this central Berlin district."""

Mitte = boundaries[
    (boundaries["name"] == "Mitte") &
    (boundaries["admin_level"] == "9")
]
print(Mitte)

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 10))
Mitte.plot(edgecolor='black', facecolor='none', linewidth=2)
plt.title("Mitte")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.show()

"""##Roads are clipped to the Mitte boundary, creating a GeoDataFrame that contains only the roads within this district for focused analysis and visualization."""

import geopandas as gpd
# Ensure fil_roads_df is a GeoDataFrame with correct CRS
fil_roads_gdf = gpd.GeoDataFrame(roads_df_filterd, geometry='geometry', crs='EPSG:4326')

# Clip roads to mitte boundary
roads_mitte = gpd.clip(fil_roads_gdf, Mitte)
print(roads_mitte.head())

"""## Visualizing Mitte Boundary and Road Network

* The coordinate reference systems (CRS) of Mitte and the roads are checked to ensure alignment for accurate mapping.

* The Mitte boundary and its roads are plotted, with roads colored by highway type, providing a visual overview of the district’s road network.

* The plot uses equal aspect ratio and hides axes for a clear, scaled


"""

print(Mitte.crs)
print(fil_roads_gdf.crs)

import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(13, 10))
Mitte.boundary.plot(
    ax=ax,
    edgecolor='black',
    linewidth=2,
    label='Mitte'
)
roads_mitte.plot(
    ax=ax,
    column='highway',
    linewidth=1,
    legend=True,
    cmap='tab20'
)

ax.set_title("Mitte")
ax.set_aspect('equal')
ax.axis('off')
plt.show()

"""## Grid Generation and Centroid Computation for Mitte
* Mitte and its roads are reprojected to UTM (EPSG:32633) for accurate distance and area calculations in meters.

* A 500 m × 500 m grid is created over the district bounding box to divide the area into manageable spatial units.

* The grid is clipped to the Mitte boundary, keeping only cells within the district.

* Centroids of each grid cell are computed in UTM and later converted to WGS84 (latitude/longitude) for mapping or integration with other data.

* The resulting grid, centroids, and roads are plotted together to verify alignment and spatial coverage.

* The final dataset contains grid polygons, centroid geometries, and their lat/lon coordinates for further analysis.
"""

# Reproject to UTM (meters) for Berlin
#Mitte_utm = Mitte.to_crs(epsg=32633)
#roads_mitte_utm = roads_mitte.to_crs(epsg=32633)

from shapely.geometry import box
import matplotlib.pyplot as plt

Mitte_utm = Mitte.to_crs(epsg=32633)
roads_mitte_utm = roads_mitte.to_crs(epsg=32633)

#grid of 500m in meters
grid_size = 500
minx, miny, maxx, maxy = Mitte_utm.total_bounds

grid_cells = []
x = minx
while x < maxx:
    y = miny
    while y < maxy:
        grid_cells.append(box(x, y, x + grid_size, y + grid_size))
        y += grid_size
    x += grid_size

grid = gpd.GeoDataFrame({'geometry': grid_cells}, crs=Mitte_utm.crs)

grid_clipped = gpd.clip(grid, Mitte_utm)

grid_clipped['centroid'] = grid_clipped.geometry.centroid

grid_clipped_wgs = grid_clipped.to_crs(epsg=4326)

# Use the already computed centroid (UTM) for lat/lon
grid_clipped_wgs['centroid_lon'] = grid_clipped_wgs['centroid'].x
grid_clipped_wgs['centroid_lat'] = grid_clipped_wgs['centroid'].y

fig, ax = plt.subplots(figsize=(13, 10))

Mitte_utm.boundary.plot(ax=ax, edgecolor='black', linewidth=2)

grid_clipped.boundary.plot(ax=ax, edgecolor='blue', linewidth=0.5)

roads_mitte_utm.plot(ax=ax, color='red', linewidth=0.6)

ax.set_aspect('equal')
ax.axis('off')
plt.title("Mitte – 500m Grid & Roads")
plt.show()

"""## Interactive Map of Mitte with Grid and Roads

* Grid cell areas are calculated and compared to the expected 250,000 m² (500 m × 500 m) to confirm correct sizing before mapping or further processing.

* Grid cells, roads, and the Mitte boundary are converted to WGS84 for mapping.

* Highway types are assigned distinct colors for clear visualization.

* The map is centered on Mitte’s centroid and includes the grid, roads, and district boundary for interactive exploration.

* Folium allows zooming and panning to inspect the spatial layout of the district.
"""

print(grid_clipped.geometry.area.mean())

print(grid.geometry.area.head())
print(grid.geometry.area.mean())

"""With folium"""

import folium
import branca.colormap as cm

grid_wgs = grid_clipped.to_crs(epsg=4326)
roads_wgs = roads_mitte.to_crs(epsg=4326)
Mitte_wgs = Mitte.to_crs(epsg=4326)

types = roads_wgs['highway'].unique()
colors = cm.linear.Set1_09.scale(0, len(types)).to_step(len(types))

type_color = {t: colors.rgb_hex_str(i) for i, t in enumerate(types)}

center_utm = Mitte.to_crs(epsg=32633).geometry.centroid
center_wgs = center_utm.to_crs(epsg=4326)
center = [center_wgs.y.mean(), center_wgs.x.mean()]

map_grid = folium.Map(
    location=center,
    zoom_start=14,
    tiles="cartodbpositron"
)


for _, row in grid_wgs.iterrows():
    folium.GeoJson(
        row.geometry,
        style_function=lambda feature: {
            "color": "blue",
            "weight": 1,
            "fillOpacity": 0
        }
    ).add_to(map_grid)

for _, row in roads_wgs.iterrows():
    highway_type = row['highway']
    color = type_color.get(highway_type, 'black')

    folium.GeoJson(
        row.geometry,
        style_function=lambda feature, col=color: {
            "color": col,
            "weight": 2
        }
    ).add_to(map_grid)

folium.GeoJson(
    Mitte_wgs,
    style_function=lambda feature: {
        "color": "red",
        "weight": 2,
        "fillOpacity": 0
    }
).add_to(map_grid)

map_grid.save("Mitte_Grid.html")

map_grid

"""With matplotlib"""

Mitte_utm = Mitte.to_crs(epsg=32633)
roads_mitte_utm = roads_mitte.to_crs(epsg=32633)

grid_size = 500  # meters
minx, miny, maxx, maxy = Mitte_utm.total_bounds

grid_cells = []
x = minx
while x < maxx:
    y = miny
    while y < maxy:
        grid_cells.append(box(x, y, x + grid_size, y + grid_size))
        y += grid_size
    x += grid_size

grid = gpd.GeoDataFrame({'geometry': grid_cells}, crs=Mitte_utm.crs)

grid_clipped = gpd.clip(grid, Mitte_utm)

grid_clipped['centroid'] = grid_clipped.geometry.centroid

grid_clipped_wgs = grid_clipped.to_crs(epsg=4326)

grid_clipped_wgs['centroid_lon'] = grid_clipped_wgs['centroid'].x
grid_clipped_wgs['centroid_lat'] = grid_clipped_wgs['centroid'].y

fig, ax = plt.subplots(figsize=(13, 10))

Mitte_utm.boundary.plot(ax=ax, edgecolor='black', linewidth=2, label='Mitte')

grid_clipped.boundary.plot(ax=ax, edgecolor='blue', linewidth=0.5)

roads_mitte_utm.plot(
    ax=ax,
    column='highway',
    linewidth=1,
    legend=True,
    cmap='tab20'
)

ax.set_aspect('equal')
ax.axis('off')
plt.title("Mitte – 500m Grid & Roads by Type")
plt.show()

"""##Grid Centroid Extraction (Lat/Lon)
* Grid cells are projected to a metric CRS (UTM) to compute accurate centroids in meters.

* Centroids are converted back to WGS84 (latitude/longitude) for mapping or API integration.

* A DataFrame of centroid coordinates with unique cell IDs is created for further analysis or weather data retrieval.
"""

grid_projected = grid_clipped.to_crs(epsg=32633)

grid_projected['centroid'] = grid_projected.geometry.centroid

grid_centroids_wgs = grid_projected.copy()
grid_centroids_wgs['centroid'] = grid_projected['centroid'].to_crs(epsg=4326)

centroids_api = pd.DataFrame({
    'longitude': grid_centroids_wgs['centroid'].x,
    'latitude': grid_centroids_wgs['centroid'].y,
    'cell_id': range(1, len(grid_clipped) + 1)
})

print(centroids_api.head())

!pip install openmeteo-requests
!pip install requests-cache retry-requests numpy pandas

"""## Fetching Historical Weather Data from Open-Meteo
* Required packages are installed, including openmeteo-requests, caching, and retry utilities.
* Open-Meteo client is set up with caching and retry logic to improve efficiency and reliability.

* Historical weather parameters include temperature, dew point, relative humidity, and 10 m wind speed.

* For each grid cell centroid, hourly weather data is fetched for the specified date range.

* Hourly data is extracted and converted into NumPy arrays, with a datetime index constructed for each observation.

* Data for all grid cells is combined into a single DataFrame containing cell ID, location, datetime, and weather variables.

* The resulting DataFrame allows analysis of meteorological conditions across the Mitte grid.

---

## Data reference

* The meteorological dataset analyzed in this study corresponds to 06 November 2024, with hourly temporal resolution.

* On this date, official low-visibility warnings due to fog were issued, including driving advisories.

* This event provides a relevant real-world case for evaluating the effectiveness of the proposed fog detection and Fog Density Index (FDI).

* It serves as a practical opportunity to cross-check whether the developed FDI accurately captures and represents the observed fog conditions.

link of news article: https://www.berliner-zeitung.de/news/wetter-in-berlin-amtliche-warnung-vor-nebel-am-dienstagmorgen-li.2269382

code refered from direct API page - open meteo
"""

import openmeteo_requests
import pandas as pd
import requests_cache
from retry_requests import retry

cache_session = requests_cache.CachedSession('.cache', expire_after=3600)
retry_session = retry(cache_session, retries=5, backoff_factor=0.2)
openmeteo = openmeteo_requests.Client(session=retry_session)

start_date = "2024-11-06"
end_date   = "2024-11-06"
variables  = ["temperature_2m", "dew_point_2m", "relative_humidity_2m", "wind_speed_10m"]

all_hourly_data = []

for idx, row in centroids_api.iterrows():
    lat = row['latitude']
    lon = row['longitude']
    cell_id = row['cell_id']

    params = {
        "latitude": lat,
        "longitude": lon,
        "start_date": start_date,
        "end_date": end_date,
        "hourly": variables
    }

   #API Call
    responses = openmeteo.weather_api(
        "https://historical-forecast-api.open-meteo.com/v1/forecast",
        params=params
    )

    response = responses[0]

    hourly = response.Hourly()


    temp = hourly.Variables(0).ValuesAsNumpy()
    dew = hourly.Variables(1).ValuesAsNumpy()
    rh   = hourly.Variables(2).ValuesAsNumpy()
    wind = hourly.Variables(3).ValuesAsNumpy()

    dates = pd.date_range(
        start=pd.to_datetime(hourly.Time(), unit="s", utc=True),
        end=pd.to_datetime(hourly.TimeEnd(), unit="s", utc=True),
        freq=pd.Timedelta(seconds=hourly.Interval()),
        inclusive="left"
    )

    df_cell = pd.DataFrame({
        "cell_id": cell_id,
        "latitude": lat,
        "longitude": lon,
        "datetime_utc": dates,
        "temperature_2m": temp,
        "dew_point_2m": dew,
        "relative_humidity_2m": rh,
        "wind_speed_10m": wind
    })

    all_hourly_data.append(df_cell)

weather_df = pd.concat(all_hourly_data, ignore_index=True)
print(weather_df.head())

"""## Calculating Fog Detection Index (FDI) and Visibility
* Wind speed from Open-Meteo (km/h) is converted to meters per second for consistency.

* Dew point depression (temperature - dew point) is computed as an indicator of condensation potential.

* Each FDI component—relative humidity, dew point depression, and wind speed—is normalized to a 0–1 scale.

* FDI is calculated as a weighted sum: 0.4 × RH + 0.4 × dew point factor + 0.2 × wind factor.

* FDI values are mapped to visibility categories and driving conditions, ranging from clear to very dangerous fog.

* The final DataFrame includes cell ID, location, datetime, weather variables, FDI, visibility, and driving condition.

* Results are previewed and saved to a CSV file for further analysis.



---

## Formula Details and References

1. Dew Point Depression (ΔTd = T − Td)

* Measures how close air is to saturation; smaller values → higher fog probability.

* Used directly in fog observation studies (Imteaz et al., 2011; REAL-Fog paper).

2. Relative Humidity (RH)

* High RH indicates near-saturation. Normalized in the code as (RH − 95)/5 clipped to 0–1.

* Conceptually approximates RH ≥ 97% threshold used in operational fog diagnostics and research.

3. Wind Speed (U)

* Low wind allows fog formation and persistence; strong wind disperses fog.

* Normalized in the code as 1 − (U / 5), consistent with studies on fog persistence (Imteaz et al., 2011).

4. Fog Density Index (FDI)

* Weighted combination: FDI = 0.4 * RH_norm + 0.4 * D_norm + 0.2 * W_norm

* Captures relative contribution of humidity, dew point, and wind.

* Higher FDI → denser fog → lower visibility.

5. Visibility Categories for Drivers

* FDI < 0.3 → Clear (>1000 m)

* 0.3–0.5 → Light fog (500–1000 m)

* 0.5–0.7 → Moderate fog (200–500 m)

* 0.7–0.9 → Dense fog (50–200 m)

* 0.9 → Very dangerous (<50 m)

Based on road weather visibility classifications and empirical fog studies.

4. References / Basis of Formulas

* [Imteaz et al., 2011 — Fog Potential Index](https://www.sciencedirect.com/science/article/abs/pii/S0921344911001947)

* [REAL-Fog paper — near-saturation conceptual logic](https://www.researchgate.net/publication/339074628_REAL-Fog_A_simple_approach_for_calculating_the_fog_in_the_atmosphere_at_ground_level)

* [Operational fog diagnostics -aviation and road weather](https://www.tarmacview.com/glossary/fog/)

* [Wei et al. — multi-parameter visibility models](https://medcraveonline.com/IJH/IJH-06-00312.pdf)


* [How Fog is formed?- Wikipideia](https://https://en.wikipedia.org/wiki/Fog?)
"""

# Convert wind speed (km/h) to m/s
weather_df['U'] = weather_df['wind_speed_10m'] / 3.6

# Dew point depression
weather_df['delta_Td'] = weather_df['temperature_2m'] - weather_df['dew_point_2m']

# Normalize components for FDI
weather_df['RH_norm'] = ((weather_df['relative_humidity_2m'] - 95)/5).clip(0,1)
weather_df['D_norm'] = (1 - (weather_df['delta_Td'] / 2)).clip(0,1)
weather_df['W_norm'] = (1 - (weather_df['U'] / 5)).clip(0,1)

# Compute FDI
weather_df['FDI'] = 0.4 * weather_df['RH_norm'] + 0.4 * weather_df['D_norm'] + 0.2 * weather_df['W_norm']

def map_visibility(fdi):
    if fdi < 0.3:
        return "> 1000 m", "Clear"
    elif 0.3 <= fdi < 0.5:
        return "500–1000 m", "Light fog"
    elif 0.5 <= fdi < 0.7:
        return "200–500 m", "Moderate fog"
    elif 0.7 <= fdi < 0.9:
        return "50–200 m", "Dense fog"
    else:
        return "< 50 m", "Very dangerous"

weather_df[['visibility', 'driving_condition']] = weather_df['FDI'].apply(lambda x: pd.Series(map_visibility(x)))

print(weather_df.head(10))
weather_df.to_csv("Mitte_calculated_weather1.csv", index=False)

"""## Visualization with Folium
* Convert all spatial layers (grid, roads, district boundary) to WGS84 (EPSG:4326) for web map compatibility.

* Assign colors to different road types for clear visualization of the road network.

* Convert visibility categories into numerical fog intensity weights and organize data hourly.

* Create a time-animated heatmap to visualize spatial and temporal fog intensity for driving risk assessment.
"""

import branca.colormap as cm
from folium.plugins import HeatMapWithTime
import pandas as pd

grid_wgs = grid_clipped.to_crs(epsg=4326)
roads_wgs = roads_mitte.to_crs(epsg=4326)
Mitte_wgs = Mitte.to_crs(epsg=4326)

types = roads_wgs['highway'].unique()
colors = cm.linear.Set1_09.scale(0, len(types)).to_step(len(types))
type_color = {t: colors.rgb_hex_str(i) for i, t in enumerate(types)}


center_utm = Mitte.to_crs(epsg=32633).geometry.centroid
center_wgs = center_utm.to_crs(epsg=4326)
center = [center_wgs.y.mean(), center_wgs.x.mean()]

map_grid = folium.Map(
    location=center,
    zoom_start=14,
    tiles="cartodbpositron"
)

for _, row in grid_wgs.iterrows():
    folium.GeoJson(
        row.geometry,
        style_function=lambda feature: {
            "color": "blue",
            "weight": 1,
            "fillOpacity": 0
        }
    ).add_to(map_grid)

for _, row in roads_wgs.iterrows():
    highway_type = row['highway']
    color = type_color.get(highway_type, 'black')

    folium.GeoJson(
        row.geometry,
        style_function=lambda feature, col=color: {
            "color": col,
            "weight": 2
        }
    ).add_to(map_grid)

folium.GeoJson(
    Mitte_wgs,
    style_function=lambda feature: {
        "color": "red",
        "weight": 2,
        "fillOpacity": 0
    }
).add_to(map_grid)


weather_df['datetime_utc'] = pd.to_datetime(weather_df['datetime_utc'])
hours = sorted(weather_df['datetime_utc'].unique())

heat_data_time = []
for hr in hours:
    df_hour = weather_df[weather_df['datetime_utc'] == hr]
    hour_data = []
    for _, row in df_hour.iterrows():
        vis = row['visibility']
        if vis == "> 1000 m":
            w = 0.1
        elif vis == "500–1000 m":
            w = 0.3
        elif vis == "200–500 m":
            w = 0.5
        elif vis == "50–200 m":
            w = 0.7
        else:
            w = 1.0
        hour_data.append([row['latitude'], row['longitude'], w])
    heat_data_time.append(hour_data)


HeatMapWithTime(
    heat_data_time,
    index=[str(h) for h in hours],
    auto_play=False,
    max_opacity=0.8,
    radius=75,
    use_local_extrema=False
).add_to(map_grid)

map_grid
map_grid.save("Mitte_FDI.html")

map_grid

"""## For another day  (06th Feb 2026)




"""

cache_session = requests_cache.CachedSession('.cache', expire_after=3600)
retry_session = retry(cache_session, retries=5, backoff_factor=0.2)
openmeteo = openmeteo_requests.Client(session=retry_session)


start_date = "2026-02-06"
end_date   = "2026-02-06"
variables  = ["temperature_2m", "dew_point_2m", "relative_humidity_2m", "wind_speed_10m"]

all_hourly_data = []

for idx, row in centroids_api.iterrows():
    lat = row['latitude']
    lon = row['longitude']
    cell_id = row['cell_id']

    params = {
        "latitude": lat,
        "longitude": lon,
        "start_date": start_date,
        "end_date": end_date,
        "hourly": variables
    }


    responses = openmeteo.weather_api(
        "https://historical-forecast-api.open-meteo.com/v1/forecast",
        params=params
    )

    response = responses[0]

    hourly = response.Hourly()

    temp = hourly.Variables(0).ValuesAsNumpy()
    dew = hourly.Variables(1).ValuesAsNumpy()
    rh   = hourly.Variables(2).ValuesAsNumpy()
    wind = hourly.Variables(3).ValuesAsNumpy()

    dates = pd.date_range(
        start=pd.to_datetime(hourly.Time(), unit="s", utc=True),
        end=pd.to_datetime(hourly.TimeEnd(), unit="s", utc=True),
        freq=pd.Timedelta(seconds=hourly.Interval()),
        inclusive="left"
    )

    df_cell = pd.DataFrame({
        "cell_id": cell_id,
        "latitude": lat,
        "longitude": lon,
        "datetime_utc": dates,
        "temperature_2m": temp,
        "dew_point_2m": dew,
        "relative_humidity_2m": rh,
        "wind_speed_10m": wind
    })

    all_hourly_data.append(df_cell)

weather_df = pd.concat(all_hourly_data, ignore_index=True)

print(weather_df.head())

weather_df['U'] = weather_df['wind_speed_10m'] / 3.6

weather_df['delta_Td'] = weather_df['temperature_2m'] - weather_df['dew_point_2m']

weather_df['RH_norm'] = ((weather_df['relative_humidity_2m'] - 95)/5).clip(0,1)
weather_df['D_norm'] = (1 - (weather_df['delta_Td'] / 2)).clip(0,1)
weather_df['W_norm'] = (1 - (weather_df['U'] / 5)).clip(0,1)

weather_df['FDI'] = 0.4 * weather_df['RH_norm'] + 0.4 * weather_df['D_norm'] + 0.2 * weather_df['W_norm']

def map_visibility(fdi):
    if fdi < 0.3:
        return "> 1000 m", "Clear"
    elif 0.3 <= fdi < 0.5:
        return "500–1000 m", "Light fog"
    elif 0.5 <= fdi < 0.7:
        return "200–500 m", "Moderate fog"
    elif 0.7 <= fdi < 0.9:
        return "50–200 m", "Dense fog"
    else:
        return "< 50 m", "Very dangerous"

weather_df[['visibility', 'driving_condition']] = weather_df['FDI'].apply(lambda x: pd.Series(map_visibility(x)))

print(weather_df.head(10))
weather_df.to_csv("Mitte_calculated_weather2.csv", index=False)

grid_wgs = grid_clipped.to_crs(epsg=4326)
roads_wgs = roads_mitte.to_crs(epsg=4326)
Mitte_wgs = Mitte.to_crs(epsg=4326)

types = roads_wgs['highway'].unique()
colors = cm.linear.Set1_09.scale(0, len(types)).to_step(len(types))
type_color = {t: colors.rgb_hex_str(i) for i, t in enumerate(types)}


center_utm = Mitte.to_crs(epsg=32633).geometry.centroid
center_wgs = center_utm.to_crs(epsg=4326)
center = [center_wgs.y.mean(), center_wgs.x.mean()]


map_grid = folium.Map(
    location=center,
    zoom_start=14,
    tiles="cartodbpositron"
)

for _, row in grid_wgs.iterrows():
    folium.GeoJson(
        row.geometry,
        style_function=lambda feature: {
            "color": "blue",
            "weight": 1,
            "fillOpacity": 0
        }
    ).add_to(map_grid)


for _, row in roads_wgs.iterrows():
    highway_type = row['highway']
    color = type_color.get(highway_type, 'black')

    folium.GeoJson(
        row.geometry,
        style_function=lambda feature, col=color: {
            "color": col,
            "weight": 2
        }
    ).add_to(map_grid)

folium.GeoJson(
    Mitte_wgs,
    style_function=lambda feature: {
        "color": "red",
        "weight": 2,
        "fillOpacity": 0
    }
).add_to(map_grid)

weather_df['datetime_utc'] = pd.to_datetime(weather_df['datetime_utc'])
hours = sorted(weather_df['datetime_utc'].unique())

heat_data_time = []
for hr in hours:
    df_hour = weather_df[weather_df['datetime_utc'] == hr]
    hour_data = []
    for _, row in df_hour.iterrows():
        vis = row['visibility']
        if vis == "> 1000 m":
            w = 0.1
        elif vis == "500–1000 m":
            w = 0.3
        elif vis == "200–500 m":
            w = 0.5
        elif vis == "50–200 m":
            w = 0.7
        else:
            w = 1.0
        hour_data.append([row['latitude'], row['longitude'], w])
    heat_data_time.append(hour_data)

HeatMapWithTime(
    heat_data_time,
    index=[str(h) for h in hours],
    auto_play=False,
    max_opacity=0.8,
    radius=75,
    use_local_extrema=False
).add_to(map_grid)

map_grid.save("Mitte_FDI2.html")

map_grid



"""## Conclusion
* This study presents an initial framework for estimating fog presence and fog severity using a Fog Density Index (FDI) derived from surface meteorological parameters.

* The methodology combines dew point depression, relative humidity, and wind speed into a normalized multi-parameter index suitable for driving-related fog risk assessment.

* The selected case study of 06 November 2024, during which official fog and low-visibility warnings were issued, provided a practical real-world scenario for validation of the proposed Fog Density Index (FDI).

* Additionally, 06 February 2026, a day characterized by comparatively lower fog presence, was analyzed to assess the model’s behavior under less severe conditions.

* The results demonstrate that the FDI responds consistently to varying atmospheric conditions, showing higher fog density values during confirmed fog events and lower values during clearer conditions.

* The hourly output further illustrates the temporal evolution of fog intensity, capturing how fog density increases and decreases throughout the day in accordance with changing meteorological conditions.

* The prototype implementation for Berlin demonstrates that the FDI approach is capable of detecting fog conditions and reflecting expected visibility reductions consistent with observed warnings.

* While the model does not compute physical liquid water content or exact visibility in meters, it provides a reliable first-order fog risk indicator based on publicly available meteorological data.

* As a prototype, this framework establishes a foundation for future improvements, including validation against airport visibility observations, refinement of threshold values, and potential integration into route-based driver advisory systems.

* Overall, the results indicate that the proposed FDI approach is a practical, scalable, and operationally relevant method for urban fog risk assessment.
"""

